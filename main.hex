#include <std/mem.pat>
#include <civ6save.hexpat>
#include <civ6save_numbers.hexpat>

// start looking from 0 for bytes `0x0E, 0, 0, 0, 0x0F, 0, 0, 0, 0x06, 0, 0, 0`.
s128 start = std::mem::find_sequence(0, 0x0E, 0, 0, 0, 0x0F, 0, 0, 0, 0x06, 0, 0, 0) + 16;

u32 numTiles @ start - 4;
Tile tiles[numTiles] @ start;


// These are structures in the start of the save file, before 'tiles'
char uuid[] @ 0x0000002C;
u32 player_flags[64] @ 0x00000081; // players, city states & barbarians
u32 incrementals[64] @ 0x00000181;

NumValsPad32 nums__1[2] @ 0x00000782;

u8 unknown_nums__1_2[4] @ after(nums__1);
u32 num_nums__2 @ after(unknown_nums__1_2);
Nums__2_SuperType nums__2[num_nums__2] @ after(unknown_nums__1_2) + 4;
u8 unknown_nums__2_3[16] @ after(nums__2);
u32 num_nums__3 @ after(unknown_nums__2_3);
Nums__3_SuperType nums__3[num_nums__3] @ after(unknown_nums__2_3) + 4;

u32 nums__4a[1] @ after(nums__3);
u32 nums__4b[1] @ after(nums__4a);
u32 nums__4c[nums__4b[0] + 2] @ after(nums__4b); // numbers are close to nums__4a
u32 nums__4d[3] @ after(nums__4c); // 3x fixed numbers between 4 saves 
u32 nums__4d2[1] @ after(nums__4d); // + 1 extra number, similar to unknown_nums__2_3

u32 nums__5[1] @ after(nums__4d2);
u8 nums__5b[nums__5[0]*25] @ after(nums__5);

u32 nums__6a[2] @ after(nums__5b);
u32 nums__6b[nums__6a[1] + 2] @ after(nums__6a);

u32 nums__7[3+1] @ after(nums__6b);

struct Nums__8_Type{
    u8 header[21];
    NumVals;
};
u32 num_nums__8[1] @ after(nums__7);
Nums__8_Type nums__8[num_nums__8[0]] @ after(num_nums__8);

u32 nums__9[1] @ after(nums__8);
u32 nums__10[1] @ after(nums__9);
u32 nums__10b[nums__10[0] + 2] @ after(nums__10);

u32 nums__11[5] @ after(nums__10b);
u32 nums__11_header0[1] @ after(nums__11); // expected to be '1'

struct Nums__12_Type{
    u8 header1[5];
    u32 start1;
    u32 values1[4];
    u32 values2_num;
    u32 values2[values2_num * 2];
    u32 values3_num;
    u32 values3[values3_num + 2];
};

Nums__12_Type nums__12[nums__11[3]] @ after(nums__11_header0);

u32 num_nums__13[1] @ after(nums__12) - 4;
u32 nums__13[num_nums__13[0] + 2] @ after(num_nums__13);

u32 nums__14[1] @ after(nums__13);
u32 nums__14b[nums__14[0] * 5] @ after(nums__14);

u32 nums__15[3] @ after(nums__14b);

u32 nums__16[1] @ after(nums__15);
u32 num_nums__17[1] @ after(nums__16);

struct Nums__17_Type{
    u32 id;
    u16 id_value;
    u32 num;
    u16 values[num];
};
Nums__17_Type nums__17[num_nums__17[0]] @ after(num_nums__17);
u32 nums__18[1] @ after(nums__17);
u32 num_nums__19[1] @ after(nums__18);
u32 nums__19[num_nums__19[0] + 2] @ after(num_nums__19);
u32 nums__20[1] @ after(nums__19);

printGap(nums__20, tiles);
